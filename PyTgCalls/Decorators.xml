<page>
    <h1>Decorators</h1>
    <text>
        While still being methods bound to the <docs-ref link="">PyTgCalls</docs-ref> class, decorators are of a special kind and thus deserve a dedicated page.

        Decorators are able to register callback functions for handling updates in a much easier and cleaner way; all you need to do is adding the decorators on top of your functions.
    </text>
    <syntax-highlight mark="7">
        from pytgcalls import PyTgCalls
        from pytgcalls.types import Update
        ...
        client = # Here Your MtProto Client
        app = PyTgCalls(client)

        @app.on_raw_update()
        async def my_handler(client: PyTgCalls, update: Update):
            print(message)

        app.run()
    </syntax-highlight>
    <separator/>
    <h1>PyTgCalls Decorators</h1>
    <br/>
    <category>
        <category-title><ref>@PyTgCalls.<sb>on_closed_voice_chat</sb></ref>()</category-title>
        <subtext>
            Decorator for handling the closed voice chat event.

            When a video chat closes, this decorator will be triggered
            <h3>Example</h3>
            <syntax-highlight mark="4-5">
                ...
                app = PyTgCalls(client)
                ...
                @app.on_closed_voice_chat()
                async def handler(client: PyTgCalls, chat_id: int):
                    print(chat_id)
                ...
                app.run()
            </syntax-highlight>
        </subtext>
        <br/><br/>
        <category-title><ref>@PyTgCalls.<sb>on_group_call_invite</sb></ref>()</category-title>
        <subtext>
            Decorator for handling invites to the voice chat.

            When your userbot is invited to the voice chat, this decorator will be triggered
            <h3>Example</h3>
            <syntax-highlight mark="4-5">
                ...
                app = PyTgCalls(client)
                ...
                @app.on_group_call_invite()
                async def handler(client: PyTgCalls, service_msg):
                    print(chat_id)
                ...
                app.run()
            </syntax-highlight>
        </subtext>
        <br/><br/>
        <category-title><ref>@PyTgCalls.<sb>on_kicked</sb></ref>()</category-title>
        <subtext>
            Decorator for handling when kicked from a group/channel.

            When your userbot is kicked from a group/channel, this decorator will be triggered
            <h3>Example</h3>
            <syntax-highlight mark="4-5">
                ...
                app = PyTgCalls(client)
                ...
                @app.on_kicked()
                async def handler(client: PyTgCalls, service_msg):
                    print(chat_id)
                ...
                app.run()
            </syntax-highlight>
        </subtext>
        <br/><br/>
        <category-title><ref>@PyTgCalls.<sb>on_left</sb></ref>()</category-title>
        <subtext>
            Decorator for handling when the userbot leaves a group/channel.

            When your userbot leaves a group/channel, this decorator will be triggered
            <h3>Example</h3>
            <syntax-highlight mark="4-5">
                ...
                app = PyTgCalls(client)
                ...
                @app.on_left()
                async def handler(client: PyTgCalls, chat_id: int):
                    print(chat_id)
                ...
                app.run()
            </syntax-highlight>
        </subtext>
        <br/><br/>
        <category-title><ref>@PyTgCalls.<sb>on_participants_change</sb></ref>()</category-title>
        <subtext>
            Decorator for handling when the participant list of a group call is changed.

            When the participant list changes, this decorator will be triggered
            <h3>Example</h3>
            <syntax-highlight mark="4-5">
                ...
                app = PyTgCalls(client)
                ...
                @app.on_participants_change()
                async def handler(client: PyTgCalls, update: Update):
                    print(chat_id)
                ...
                app.run()
            </syntax-highlight>
        </subtext>
    </category>
    <br/>
    <h1>CustomApi Decorators</h1>
    <category-title><ref><sb>@on_update_custom_api</sb></ref>()</category-title>
    <subtext>
        <text>Decorator for handling incoming http events</text>
        <pg-title>RAISES</pg-title>
        <subtext>
            <category-title>exception <ref>pytgcalls.exceptions.<sb>TooManyCustomApiDecorators</sb></ref></category-title>
            <subtext><text>You set too many decorators.</text></subtext>
        </subtext>
        <h3>Example</h3>
        <syntax-highlight mark="4-5">
            ...
            webserver = CustomApi(client)
            ...
            @webserver.on_update_custom_api()
            async def handler(request: dict):
                print(update)
                ... # Add Your Code here, switch or etc.
                return {
                    'result': 'OK',
                }
            webserver.start()
            idle()
        </syntax-highlight>
    </subtext>
</page>